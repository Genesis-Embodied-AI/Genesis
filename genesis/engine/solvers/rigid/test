
    @ti.func
    def _func_compute_mass_matrix(
        self_unused,
        implicit_damping: ti.template(),
        # taichi variables
        links_state: array_class.LinksState,
        links_info: array_class.LinksInfo,
        dofs_state: array_class.DofsState,
        entities_info: array_class.EntitiesInfo,
        rigid_global_info: array_class.RigidGlobalInfo,
        static_rigid_sim_config: ti.template(),
    ):
        _B = links_state.shape[1]
        rgi = rigid_global_info
        if ti.static(static_rigid_sim_config.use_hibernation):
            # crb initialize
            ti.loop_config(serialize=static_rigid_sim_config.para_level < gs.PARA_LEVEL.ALL)
            for i_b in range(_B):
                for i_l_ in range(rigid_global_info.n_awake_links[i_b]):
                    i_l = rigid_global_info.awake_links[i_l_, i_b]
                    links_state[i_l, i_b].crb_inertial = links_state[i_l, i_b].cinr_inertial
                    links_state[i_l, i_b].crb_pos = links_state[i_l, i_b].cinr_pos
                    links_state[i_l, i_b].crb_quat = links_state[i_l, i_b].cinr_quat
                    links_state[i_l, i_b].crb_mass = links_state[i_l, i_b].cinr_mass

            # crb
            ti.loop_config(serialize=static_rigid_sim_config.para_level < gs.PARA_LEVEL.ALL)
            for i_b in range(_B):
                for i_e_ in range(rigid_global_info.n_awake_entities[i_b]):
                    i_e = rigid_global_info.awake_entities[i_e_, i_b]
                    for i in range(entities_info[i_e].n_links):
                        i_l = entities_info[i_e].link_end - 1 - i
                        I_l = [i_l, i_b] if ti.static(static_rigid_sim_config.batch_links_info) else i_l
                        i_p = links_info[I_l].parent_idx

                        if i_p != -1:
                            links_state[i_p, i_b].crb_inertial = (
                                links_state[i_p, i_b].crb_inertial + links_state[i_l, i_b].crb_inertial
                            )
                            links_state[i_p, i_b].crb_mass = (
                                links_state[i_p, i_b].crb_mass + links_state[i_l, i_b].crb_mass
                            )

                            links_state[i_p, i_b].crb_pos = (
                                links_state[i_p, i_b].crb_pos + links_state[i_l, i_b].crb_pos
                            )
                            links_state[i_p, i_b].crb_quat = (
                                links_state[i_p, i_b].crb_quat + links_state[i_l, i_b].crb_quat
                            )

            # mass_mat
            ti.loop_config(serialize=static_rigid_sim_config.para_level < gs.PARA_LEVEL.ALL)
            for i_b in range(_B):
                for i_l_ in range(rigid_global_info.n_awake_links[i_b]):
                    i_l = rigid_global_info.awake_links[i_l_, i_b]
                    I_l = [i_l, i_b] if ti.static(static_rigid_sim_config.batch_links_info) else i_l
                    l_info = links_info[I_l]
                    for i_d in range(l_info.dof_start, l_info.dof_end):
                        dofs_state[i_d, i_b].f_ang, dofs_state[i_d, i_b].f_vel = gu.inertial_mul(
                            links_state[i_l, i_b].crb_pos,
                            links_state[i_l, i_b].crb_inertial,
                            links_state[i_l, i_b].crb_mass,
                            dofs_state[i_d, i_b].cdof_vel,
                            dofs_state[i_d, i_b].cdof_ang,
                        )

            ti.loop_config(serialize=static_rigid_sim_config.para_level < gs.PARA_LEVEL.PARTIAL)
            for i_b in range(_B):
                for i_e_ in range(rigid_global_info.n_awake_entities[i_b]):
                    i_e = rigid_global_info.awake_entities[i_e_, i_b]
                    e_info = entities_info[i_e]
                    for i_d in range(e_info.dof_start, e_info.dof_end):
                        for j_d in range(e_info.dof_start, e_info.dof_end):
                            rigid_global_info.mass_mat[i_d, j_d, i_b] = (
                                dofs_state[i_d, i_b].f_ang.dot(dofs_state[j_d, i_b].cdof_ang)
                                + dofs_state[i_d, i_b].f_vel.dot(dofs_state[j_d, i_b].cdof_vel)
                            ) * rigid_global_info.mass_parent_mask[i_d, j_d]

                    # FIXME: Updating the lower-part of the mass matrix is irrelevant
                    for i_d in range(e_info.dof_start, e_info.dof_end):
                        for j_d in range(i_d + 1, e_info.dof_end):
                            rigid_global_info.mass_mat[i_d, j_d, i_b] = rigid_global_info.mass_mat[j_d, i_d, i_b]

                    # Take into account motor armature
                    for i_d in range(e_info.dof_start, e_info.dof_end):
                        I_d = [i_d, i_b] if ti.static(static_rigid_sim_config.batch_dofs_info) else i_d
                        rigid_global_info.mass_mat[i_d, i_d, i_b] = rigid_global_info.mass_mat[i_d, i_d, i_b] + dofs_info[I_d].armature

                    # Take into account first-order correction terms for implicit integration scheme right away
                    if ti.static(implicit_damping):
                        for i_d in range(e_info.dof_start, e_info.dof_end):
                            I_d = [i_d, i_b] if ti.static(static_rigid_sim_config.batch_dofs_info) else i_d
                            rigid_global_info.mass_mat[i_d, i_d, i_b] += dofs_info[I_d].damping * self._substep_dt
                            if (dofs_state[i_d, i_b].ctrl_mode == gs.CTRL_MODE.POSITION) or (
                                dofs_state[i_d, i_b].ctrl_mode == gs.CTRL_MODE.VELOCITY
                            ):
                                # qM += d qfrc_actuator / d qvel
                                mass_mat[i_d, i_d, i_b] += dofs_info[I_d].kv * self._substep_dt
        else:
            # crb initialize
            ti.loop_config(serialize=static_rigid_sim_config.para_level < gs.PARA_LEVEL.ALL)
            for i_l, i_b in ti.ndrange(self.n_links, self._B):
                self.links_state[i_l, i_b].crb_inertial = self.links_state[i_l, i_b].cinr_inertial
                self.links_state[i_l, i_b].crb_pos = self.links_state[i_l, i_b].cinr_pos
                self.links_state[i_l, i_b].crb_quat = self.links_state[i_l, i_b].cinr_quat
                self.links_state[i_l, i_b].crb_mass = self.links_state[i_l, i_b].cinr_mass

            # crb
            ti.loop_config(serialize=self._para_level < gs.PARA_LEVEL.ALL)
            for i_e, i_b in ti.ndrange(self.n_entities, self._B):
                for i in range(self.entities_info[i_e].n_links):
                    i_l = self.entities_info[i_e].link_end - 1 - i
                    I_l = [i_l, i_b] if ti.static(self._options.batch_links_info) else i_l
                    i_p = self.links_info[I_l].parent_idx

                    if i_p != -1:
                        self.links_state[i_p, i_b].crb_inertial = (
                            self.links_state[i_p, i_b].crb_inertial + self.links_state[i_l, i_b].crb_inertial
                        )
                        self.links_state[i_p, i_b].crb_mass = (
                            self.links_state[i_p, i_b].crb_mass + self.links_state[i_l, i_b].crb_mass
                        )

                        self.links_state[i_p, i_b].crb_pos = (
                            self.links_state[i_p, i_b].crb_pos + self.links_state[i_l, i_b].crb_pos
                        )
                        self.links_state[i_p, i_b].crb_quat = (
                            self.links_state[i_p, i_b].crb_quat + self.links_state[i_l, i_b].crb_quat
                        )

            # mass_mat
            ti.loop_config(serialize=self._para_level < gs.PARA_LEVEL.ALL)
            for i_l, i_b in ti.ndrange(self.n_links, self._B):
                I_l = [i_l, i_b] if ti.static(self._options.batch_links_info) else i_l
                l_info = self.links_info[I_l]
                for i_d in range(l_info.dof_start, l_info.dof_end):
                    self.dofs_state[i_d, i_b].f_ang, self.dofs_state[i_d, i_b].f_vel = gu.inertial_mul(
                        self.links_state[i_l, i_b].crb_pos,
                        self.links_state[i_l, i_b].crb_inertial,
                        self.links_state[i_l, i_b].crb_mass,
                        self.dofs_state[i_d, i_b].cdof_vel,
                        self.dofs_state[i_d, i_b].cdof_ang,
                    )

            ti.loop_config(serialize=self._para_level < gs.PARA_LEVEL.PARTIAL)
            for i_e, i_b in ti.ndrange(self.n_entities, self._B):
                e_info = self.entities_info[i_e]
                for i_d, j_d in ti.ndrange((e_info.dof_start, e_info.dof_end), (e_info.dof_start, e_info.dof_end)):
                    self.mass_mat[i_d, j_d, i_b] = (
                        self.dofs_state[i_d, i_b].f_ang.dot(self.dofs_state[j_d, i_b].cdof_ang)
                        + self.dofs_state[i_d, i_b].f_vel.dot(self.dofs_state[j_d, i_b].cdof_vel)
                    ) * self.mass_parent_mask[i_d, j_d]

                # FIXME: Updating the lower-part of the mass matrix is irrelevant
                for i_d in range(e_info.dof_start, e_info.dof_end):
                    for j_d in range(i_d + 1, e_info.dof_end):
                        self.mass_mat[i_d, j_d, i_b] = self.mass_mat[j_d, i_d, i_b]

            # Take into account motor armature
            ti.loop_config(serialize=self._para_level < gs.PARA_LEVEL.ALL)
            for i_d, i_b in ti.ndrange(self.n_dofs, self._B):
                I_d = [i_d, i_b] if ti.static(self._options.batch_dofs_info) else i_d
                self.mass_mat[i_d, i_d, i_b] = self.mass_mat[i_d, i_d, i_b] + self.dofs_info[I_d].armature

            # Take into account first-order correction terms for implicit integration scheme right away
            if ti.static(implicit_damping):
                ti.loop_config(serialize=self._para_level < gs.PARA_LEVEL.ALL)
                for i_d, i_b in ti.ndrange(self.n_dofs, self._B):
                    I_d = [i_d, i_b] if ti.static(self._options.batch_dofs_info) else i_d
                    self.mass_mat[i_d, i_d, i_b] += self.dofs_info[I_d].damping * self._substep_dt
                    if (self.dofs_state[i_d, i_b].ctrl_mode == gs.CTRL_MODE.POSITION) or (
                        self.dofs_state[i_d, i_b].ctrl_mode == gs.CTRL_MODE.VELOCITY
                    ):
                        # qM += d qfrc_actuator / d qvel
                        self.mass_mat[i_d, i_d, i_b] += self.dofs_info[I_d].kv * self._substep_dt
